# 전략 패턴
  - 동일 계열의 알고리즘을 정의하고, 각 알고리즘을 캡슐화하여 이들을 상호교환이 가능하도록 만든다. 
  - 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다

ex) 동물
	- 종, 달린다, 숨쉰다 등등의 기능
	- 종에 따라서 동물을 구현가능
	- 때문에 같은 기능을 가진 종을 추가하기가 쉬움
	- 사용자는 다른 추가를 할필요가 없이 같은 기능이 존재한다면 클래스만 추가하면됨

# 파사드 패턴
- 서브시스템들의 공통적인 기능을 정의하고 단순화된 상위수준의 인터페이스를 정의
	- 상위의 인터페이스이기 때문에 다른 공통 기능도 추가가능

- 서브시스템들 사이의 종속성을 줄일 수 있음
- 사용자 입장에서는 서브 클래스에 대해서 알필요가 없이 메서드만 호출하여 서브클래스의 기능을 수행

# 팩토리 패턴
팩토리 패턴은 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴입니다. 다시 말해 여러 개의 서브 클래스를 가진 슈퍼 클래스가 있을 때 인풋에 따라 하나의 자식 클래스의 인스턴스를 리턴해주는 방식입니다.

팩토리 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브 클래스로 미룹니다.

이 패턴은 인스턴스화에 대한 책임을 객체를 사용하는 클라이언트에서 팩토리 클래스로 가져옵니다. 

- 장점
	- 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거해서 서로간의 종속성을 낮추고, 결합도를 느슨하게하며, 확장이 쉬움
	- 추상화가 제공이됨
